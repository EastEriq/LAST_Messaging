Author: Enrico; describing state of 14/8/2024

# Exploiting matlab callbacks for event response and for resource protection

A Matlab session, as known, evaluates Matlab code serially, in a single threaded, event loop based model.
To be clear, I stress that I refer here to Matlab code run by the Matlab interpreter
(or to say better JIT compiler). I'm not referring to:

1. multithreaded code running in compiled mex files, or externally dynamically linked libraries

2. parpool evaluations

Both of them fall out of the scope of running within the calling matlab session, have their own issues
about exchange of data with them while they are running, and won't be discussed here.

Under some circumstances, certain events can generate callbacks. When such callbacks are processed, the
code execution is suspended, and the associated callback function is executed. Being a function, it executes
in its own workspace. It only sees its own variables, or variables declared global, and objects of _handle_ classes
which are visible in all workspaces. Instrument stream resources (i.e. serial or udp) fall into this case, btw.

When the callback function returns, execution of the previously running code is resumed where it was interrupted.

The purpose of this document is to describe how we exploit callbacks in our code, notably with respect to
what happens if several events are received in almost concomitancy. The discussion is relevant
in this repo in the context of messaging, because one of our use cases is indeed the asynchronous
processing of incoming commands, achieved via Messenger callbacks, as detailed below.

The visibility of handle class properties (most of our objects are of this kind) within the callback function is
noteworthy, and well exploited in our codebase.

## Types of callbacks tested in our codebase

### Serial or UDP terminator received callbacks

We are talking here of the objects `serial` and `udp` which we are using though they were obsoleted in the Matlab version immediately subsequent to the one we started to work with (2020a). I am not at all sure that the same conclusions apply to the newer objects `serialport` and `udpport`. Of all callbacks which can
be defined for these two objects, I only use the udp `DatagramReceivedFcn` one, so I can strictly speak
out of experience about it.

When they are executed, the callback function shows `instrcb` as member of its `dbstack()` callchain, fact
which can be used in order to discriminate the subsequent treatment.

### Timer callbacks

As set when defining the property `TimerFcn` of a timer, i.e. `timer(...,'TimerFcn',@(~,~)....)`. There
are other actions of a timer like start, stop, error which can generate callbacks events, but I haven't
checked them in the context described here.

When they are executed, the callback function receives `timercb` as part of the callchain.

### Class property changed callbacks

They can be associated to class events for which listeners are defined, and can be programmatically
be fired with `notify()`. In our codebase, though, we only use `PostSet` property callbacks.

When they are executed, the callback function receives a function name with prefix _classname_`>`
as part of the callchain
(e.g. `obs.camera>@(varargin)CameraObj.treatNewImage(varargin{:})` for the case illustrated below).
The callback also receives arguments `Source` and `EventData` which contain information about
the event, which could also be exploited.

In true honesty, they are probably not even proper "callbacks", even though the terminology
hints it. They are simply a code notation for functions which are to be called specifically
when a class property set or get is encountered. The interpreter simply inserts these evaluations
before or after a get/set, or when it meets a notify, in a fixed way. The don't depend on
external unpredictable events. It is thus not so surprising that they behave more like
normal code than like event callbacks.

## Interruptible and noninterruptible callbacks

While matlab is executing the code of a callback which is interruptible, a second event can launch a callback,
which spawns the execution of a function at the moment it comes, whatever the first one was doing, and returns
to it at completion. I haven't checked the exact granularity of where the interruption occurs, it is probably
between statement and statement.

Uninterruptible callbacks, instead, are not interrupted. If a callback event occurs while they are executing,
it is enqueued in a special event queue, and the execution of the corresponding function is fired only after
the first terminates. Further events are all enqueued and processed in the order they arrive. I haven't tested
how deep is that queue, or what is the behavior if events launching interruptible and noninterruptible callbacks
intervene in mixed order.

The Matlab documentation mentions cursively the fact that some callbacks can be configured in either way,
but is otherwise completely silent. The only callbacks which offer this option are callbacks produced by
user interaction with an element in a Figure window (for example `uicontrol`s, or figure action elements).

Strangely I haven't found in the internet any hint of anybody really concerned with the interruptability of
user defined callback functions, so here are my empirical findings.

- **udp** callbacks: **uninterruptible** (at least by another datagram received callback)
- **timer** callbacks: **uninterruptible**
- **PostSet** callbacks connected to class property events: **interruptible**


## Exploiting callbacks for resource protection

The typical use case is that of a query of an instrument using a message passing protocol. The computer
sends a query message on a resource (e.g. a serial or tcp port) and waits for a reply. In the simplest
acception we don't want that this transaction is disturbed by a callback intervening between the request
and the reception of the reply, with another query. In most scenarios the intervening query will receive
inappropriately the answer to the first request, exit with it, and the first query will receive nothing
or the reply to the second request.

In many programming patterns, such race conditions are prevented by the use of semaphores or mutexes.
Here the concept does not apply, because of the single threadedness of Matlab. For a resource
exclusively owned by a Matlab session, there is no point in turning on a red light, whatever the way
to implement it - if the main thread is stopped waiting for the resource to become available, no other
thread is running and can declare it available when done. Intead, we make use of the callback mechanism.

In our codebase, we use a one shot `TimerFcn` callback in two instrument classes to perform a monolithic,
uninterruptible queries on the serial port. The query routine first checks if it has been already called
as a callback (in which case it shouldn't arm a further one, which wouldn't be serviced within the call).
If it has not, it starts and then stops a `timer` object, which runs the query once.

For `inst.XerxesMountBinary` it's `private/monolithicBinaryQuery` within `private/binaryQuery`.

For `inst.CelestronFocuser` it's `private/serialQueryCallback` within `private/query`.

Both these instruments use a communication protocol with messages of variable length, hence we
decided a priori not to use `BytesAvailableFcnCount` calbacks, and we make sure that a complete message
is received simply by polling frequently the resource, till a complete datagram is detected. We avoid with this
further complications of chained callbacks.

### note: resource protection by running external code

Compiled code (e.g. a mex file function, or a camera SDK function from a dynamically linked
library) is out of the reach of the Matlab interpreter, and there is no way that a Matlab
callback can interrupt a blocking routine. This way, using external code enforces monolithicity.

One could think, then, to compile the monolithic serial queries into a mex, and to avoid this contraption
of timer callbacks to ensure it. Well, the answer is no, the Matlab compiler does *not* compile code
using either `serial` or `serialport` objects, point. And to use another programming language for that,
while retaining all the pointers and property of the Matlab `serial` which we use, is absolutely out
of bandwidth.

## Exploiting callbacks for command queuing

In the Superunit-Master-Slaves model, i.e. in general for an `obs.util.SpawnedMatlab` object, we define
`Messenger` or `Listener` objects, which listen for command datagrams incoming on their predefined udp ports.

A complete datagram simply consists of as a newline terminated, single line JSON string.
The essential difference between the two is the following: Messenger objects react to an incoming datagram
by issuing a callback for `Messenger.datagramParser`. Listeners objects instead work if the hosting session
is executing an infinite loop, which polls periodically the udp resource for complete datagrams (method
`obs.util.Listener.start`).

The resulting behavior is the following:

- if a command is received by a Listener, it executes as main thread code. When completed, the
  thread resumes its infinite loop.
- if a command is received by a Messenger while code is executing in the main thread (including
  code executed as a command received by a Listener in that thread), the main code is interrupted
  for the duration of the execution of the callback
- if a command is received by a Messenger while code is already executing in a non-interruptible callback
  (an notably, a previous command received by the same messenger, or a command fired by a `timer`), a
  new event is generated, but the callback function is executed only after the currently executing one
  is done.
- if a command is received by a Listener while a callback of any type is running - that command
  is executed only after completion of the callback, because the Listener itself is suspended, and
  has no capability of launching callbacks

In short, commands fired by timers or received by Messengers enqueue one after the other, while commands
received by a Listener can be interrupted by the former.

By default, our superunit spawned masters are created with one Listener (named `MasterMessenger`)
and one Messenger (named `MasterResponder`). All the points explained above apply when sending commands
in the one or the other way to the slaves. This is reflected by the fact that the superunit has methods
like `.send` (talking to the Listener in the master) or `.sendCallback` (talking to the Messenger).
Also `Unit.Slave`s have a `.Messenger` and a `.Responder` head, to talk to the corresponding ones
in the slave sessions.

In addition, the following fact has to be kept in mind when dealing with udp stream objects. The input stream buffer
has a finite length (currently I'm using 4KB, could be easily increased, I don't know up to which
limit). Commands sent by one or several different senders to a single receiver fill this buffer.
Judging from the results in case of overflow (too many incoming messages before earlier ones are processed),
what happens is: a datagram stays in the buffer till `datagramParser` reads it; further incoming datagram
generate Datagram Received events for _each_ new terminator received, _but_ if the buffer overflows the
messages will overwrite one the other. I got the impression that the input buffer is handled as a circular
buffer, whereas the events include the pointer to the terminator position within that buffer. I may be
grossly wrong, though. In any case, a situation of buffer overflow will create havoc to the parser, mostly
resulting in incomplete JSON strings processed. I tried the best I could to detect and to mitigate this
situation inside `datagramParser` (both flavors), but caveat emptor. The length of a typical datagram
for a simple command is ~200 bytes, btw., to have a scale, but complex commands or replies with much data
can be way bigger.

(as an escape facility, the command `return` received by a Listener terminates the infinite polling loop and
returns the Matlab prompt)

### the `LAST_Handle.classCommand` method

This is a construction using `Unit.Slave.Responder.send` or `.Responder.query` for objects defined as remote
(i.e. talking to an object defined in a Slave). Examples of it are e.g. `Unit.Camera{i}`, `Unit.Focuser{i}`.
Since they cause callback execution in the slave,
what is sent with them is enqueued like explained above, and can interrupt commands previously
started with `Unit.Slave.Messenger.send`.

### a messenger command causing another messenger command

Hic sunt leones. In same cases this is possible, in most others it creates deadlocks in which both ends
wait for the reply to be received, in situations in which it cannot.

In fact, originally I used _two_ Messengers per session just to allow Slaves to query back the Master
without deadlocking, but the design was too fragile, and it is better just to stay away from it.

## Exploiting callbacks for postprocessing of a changed class property

The notable use I have for this construct is to process new images after they are read from the camera.
In fact, in `inst.QHYccd`, camera readout is initiated by a `timer` which fires when the image _should_
be ready. This calls back a function which polls the camera till an image is ready for download, and
stores the new image in the property `.LastImage`.

Two listeners are associated to the change:

- `addlistener(CameraObj,'LastImage','PostSet',@CameraObj.treatNewImage)` in class `obs.camera`
- `addlistener(UnitObj.Camera{j},'LastImage','PostSet',@UnitObj.treatNewImage)` in class `obs.unitCS`

the first (which actually happens to be executed second) is responsible for computing FWHM and reporting
arrival, the second for saving the image in FITS format.

### planned: pushes to a memory process variable (PV) cache

I have in mind Redis. I think many pushes can be implemented vanilla with a blanket property change
event in `obs.LAST_Handle` class. Stay tuned.

