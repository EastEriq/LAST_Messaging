# Exploiting matlab callbacks for event response and resource protection

A matlab session, as known, evaluates matlab code serially, in a single threaded, event loop based model.
To be clear, I stress that I refer here to matlab code run by the matlab interpreter
(or to say better JIT compiler). I'm not referring to:

1. multithreaded code running in compiled mex files, or externally dynamically linked libraries

2. parpool evaluations

Both of them fall out of the scope of running within the calling matlab session, have their own issues about exchange of data with them while they are running, and won't be discussed here.

Under some circumstances, certain events can generate callbacks. When such callbacks are processed, the
code execution is suspended, and the associated callback function is executed. Being a function, it executes
in its own workspace. It only sees its own variables, or variables declared global, elements of _handle_ classes
which are visible in all workspaces. Instrument stream resources (i.e. serial or udp) fall into this case, btw.

When the callback function returns, execution of the previously running code is resumed where it was interrupted.

The purpose of this document is to describe how we exploit callbacks in our code, notably with respect to
what happens if several events are received in sequence.

## Types of callbacks tested in our codebase

### Serial or UDP terminator received callbacks

We are talking here of the objects `serial` and `udp` which we are using though they were obsoleted in the Matlab version immediately subsequent to the one we started to work with (2020a). I presume but am not really sure if the same conclusions apply to the newer objects `serialport` and `udpport`. Of all callbacks which can
be defined for these two objects, I only use the udp `DatagramReceivedFcn` one, so I can strictly speak
out of experience about it.

When they are executed, the callback function shows `instrcb` as part of its `callchain`, fact which can be used
in order to discriminate the subsequent treatment.

### Timer callbacks

As set when defining the property `TimerFcn` of a timer, i.e. `timer(...,'TimerFcn',@(~,~)....)`. There
are other actions of a timer like start, stop, error which can generate callbacks events, but I haven't
checked them in the context described here.

When they are executed, the callback function receives `timercb` as part of the callchain,

### Class property changed callbacks



## interruptible and noninterruptible callbacks

While matlab is executing the code of a callback which is interruptible, a second event can launch a callback,
which spawns the execution of a function at the moment it comes, whatever the first one was doing, and returns
to it at completion. I haven't checked the exact granularity of where the interruption occurs, it is probably
between statement and statement.

Uninterruptible callbacks, instead, are not interrupted. If a callback event occurs while they are executing,
it is enqueued in a special event queue, and the execution of the corresponding function is fired only after
the first terminates. Further events are all enqueued and processed in the order they arrive. I haven't tested how deep is that queue, or what is the behavior if events launching interruptible and noninterruptible callbacks
intervene in mixed order.

The Matlab documentation mentions cursively the fact that some callbacks can be configured in either way,
but is otherwise completely silent. The only callbacks which offer this option are callbacks produced by
user interaction with an element in a Figure window (for example `uicontrol`s, or figure action elements).

Strangely I haven't found in the internet any hint of anybody really concerned with the interruptability of
user defined callback functions, so here are my empirical findings.

- **udp** callbacks: **interruptible**
- **timer** callbacks: **uninterruptible**
- **PostSet** callbacks connected to class property events: **interruptible**


## exploiting callbacks for resource protection

The typical use case is that of a query of an instrument using a message passing protocol. The computer
sends a query message on a resource (e.g. a serial or tcp port) and waits for a reply. In the simplest
acception we don't want that this transaction is disturbed by a callback intervening between the request
and the reception of the reply, with another query. In most scenarios the intervening query will receive
inappropriately the answer to the first request, exit with it, and the first query will receive nothing
or the reply to the second request.

In our codebase, we use a one shot `TimerFcn` callback in `inst.XerxesMountBinary` to perform a monolithic,
uninterruptible query on the serial port. The query routine first checks if it has been already called
as a callback (in which case it shouldn't arm a further one, which wouldn't be serviced within the call).
If it has not, it starts and then stops a `timer` object, which runs the query once.

For `inst.XerxesMountBinary` it's `private/monolithicBinaryQuery` within `private/binaryQuery`.

For `inst.CelestronFocuser` it's `private/serialQueryCallback` within `private/query`.

Both of these instrument use a communication protocol with messages of non fixed length, hence we
decided a priori not to use `BytesAvailableFcnCount` calbacks, and we make sure that a complete message
is received simply by polling frequently the resource, till a complete datagram is detected. We don't
run thus in further complications of chained callbacks.

## exploiting callbacks for command queuing

## exploiting callbacks for postprocessing of a changed class property

The notable use I have for this construct is to process new images after they are read from the camera.
In fact, in `inst.QHYccd`, camera readout is initiated by a `timer` which fires when the image _should_
be ready. This calls back a function which polls the camera till an image is ready for download, and
stores the new image in the property `.LastImage`.

Two listeners are associated to the change:

- `addlistener(CameraObj,'LastImage','PostSet',@CameraObj.treatNewImage)` in class `obs.camera`
- `addlistener(UnitObj.Camera{j},'LastImage','PostSet',@UnitObj.treatNewImage)` in class `obs.unitCS`

the first (which actually happens to be executed second) is responsible for computing FWHM and reporting
arrival, the second for saving the image in FITS format.
